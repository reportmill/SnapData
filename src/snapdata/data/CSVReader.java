/*
 * Copyright (c) 2010, ReportMill Software. All rights reserved.
 */
package snapdata.data;
import java.util.*;
import snap.util.*;

/**
 * A class for reading file of comma separated values, or really any separated values.
 */
public class CSVReader {

    // The field separator
    String                      _fieldSep = "\t";
    
    // The record separator
    String                      _recordSep = "\n";
    
    // Whether first row contains field names
    boolean                     _hasHeaderRow = true;
    
    // Whether fields are quoted
    boolean                     _hasQuotedFields;
    
    // The entity generated by the most previous read
    Entity                      _entity;

/**
 * Returns the field separator.
 */
public String getFieldSep()  { return _fieldSep; }

/**
 * Sets the field separator.
 */
public void setFieldSep(String aSep)  { _fieldSep = aSep; }

/**
 * Returns the record separator.
 */
public String getRecordSep()  { return _recordSep; }

/**
 * Sets the record separator.
 */
public void setRecordSep(String aSep)  { _recordSep = aSep; }

/**
 * Returns whether first row has field names.
 */
public boolean getHasHeaderRow()  { return _hasHeaderRow; }

/**
 * Sets whether first row has field names.
 */
public void setHasHeaderRow(boolean aFlag)  { _hasHeaderRow = aFlag; }

/**
 * Returns whether fields are quoted.
 */
public boolean getHasQuotedFields()  { return _hasQuotedFields; }

/**
 * Sets whether records are quoted.
 */
public void setHasQuotedFields(boolean aFlag)  { _hasQuotedFields = aFlag; }

/**
 * Reads given string and returns list of maps.
 */
public List <Map<String,String>> readFromString(String aStr, Entity anEntity)
{
    _entity = anEntity;
    return readFromString(aStr, null, true);
}

/**
 * Reads records from given string (and creates entity).
 */
public List <Map<String,String>> readFromString(String aStr, String aName, boolean doGuessFormat)
{
    // Get source string
    if(aStr==null || aStr.length()==0) return null;
    
    // If we should try to guess format, call guessFormat
    if(doGuessFormat)
        guessFormat(aStr);
    
    // Get records
    String records[] = getRecords(aStr);
    
    // Create list of lists
    List <String[]> dataset = new ArrayList();
    
    // Iterate over records, get fields and add to dataset
    for(int i=0; i<records.length; i++) { String record = records[i];
        String fields[] = getFields(record);
        dataset.add(fields);
    }
    
    // If entity not set, create from first record
    boolean createEntity = _entity==null;
    if(createEntity) {
        _entity = new Entity(aName);
    
        // Get first record
        String record0[] = dataset.get(0);
        
        // Iterate over first record
        for(int i=0; i<record0.length; i++) {
            
            // Get property name - trim quotes if needed
            String propName = getHasHeaderRow()? record0[i].trim() : "Field" + i;
            if(getHasQuotedFields() && propName.startsWith("\"") && propName.endsWith("\""))
                propName = propName.substring(1, propName.length()-1);
            
            // Create and add new property (start with type Date, so setTypeFromSample can try to refine)
            _entity.addProperty(new Property(propName, Property.Type.Date));
        }
    }
    
    // Create maps list
    List <Map<String,String>> maps = new ArrayList();

    // Iterate over records to determine property types and add rows
    for(int i=getHasHeaderRow()? 1 : 0, iMax=dataset.size(); i<iMax; i++) { String record[] = dataset.get(i);
        
        // Create map
        Map <String,String> map = new HashMap();
        
        // Iterate over entity properties
        for(int j=0, jMax=_entity.getPropertyCount(), k=0; j<jMax; j++) { Property prop = _entity.getProperty(j);
        
            // Skip properties that are private, autogenerated or relations
            if(!createEntity && (prop.isPrivate() || prop.isPrimary() || prop.isRelation())) continue;
            
            // Get field
            String field = k<record.length? record[k++].trim() : null;
            if(field==null)
                continue;
            
            // Trim quotes if needed
            if(getHasQuotedFields() && field.startsWith("\"") && field.endsWith("\""))
                field = field.substring(1, field.length()-1);
            
            // Set/update type from sample
            if(createEntity) prop.setTypeFromSample(field);
        
            // Add attributes
            map.put(prop.getName(), field);
        }
        
        // Add map
        maps.add(map);
    }
    
    // Return maps
    return maps;
}

/**
 * Analyzes the given string and sets reader format attributes.
 */
public void guessFormat(String aStr)
{
    // Iterate over common record separator to find most common separator
    String recordSep = ""; int recordSepCount = -1;
    for(String sep : new String[] { "\r\n", "\r", "\n"} ) {
        int count = 0; for(int i=aStr.indexOf(sep); i>=0; i=aStr.indexOf(sep, i+sep.length())) count++;
        if(count>recordSepCount) {
            recordSep = sep; recordSepCount = count; }
    }
    
    // Iterate over common field separator to find most common one
    String fieldSep = ""; int fieldSepCount = -1;
    for(String sep : new String[] { "\t", ",", ";"} ) {
        int count = 0; for(int i=aStr.indexOf(sep); i>=0; i=aStr.indexOf(sep, i+1)) count++;
        if(count>fieldSepCount) {
            fieldSep = sep; fieldSepCount = count; }
    }
    
    // Set most likely record & field separators
    setRecordSep(recordSep);
    setFieldSep(fieldSep);
    
    // Get quote count - if greater than number of records * 2, than we can probably assume data is quoted
    int quoteCount = -1; for(int i=0; i>=0; i=aStr.indexOf('"', i+1)) quoteCount++;
    setHasQuotedFields(quoteCount>recordSepCount*1.9);
}

/**
 * Returns the records.
 */
private String[] getRecords(String aString)  { return aString.split(getRecordSep()); }

/**
 * Returns the fields for a record.
 */
private String[] getFields(String aRecord)
{
    // Get separator and split record into fields
    String sep = getFieldSep();
    String fields[] = aRecord.split(sep);
    
    // If fields were quoted, strip quotes and see if we need to restore any separators
    if(getHasQuotedFields()) {
        
        // Iterate over fields
        for(int i=0;i<fields.length;i++) {
            
            // Get field and verify start quote
            String field = fields[i], fieldTrim = field.trim();
            if(!fieldTrim.startsWith("\"")) { System.err.println("CSVReader:getFields: unquoted field found");
                fields[i] = fieldTrim; continue; }
                
            // While no end quote, try to append next field (assume that quoted field contained separator)
            while(!fieldTrim.endsWith("\"")) {
                
                // Get next field and append to this field with separator (normal case)
                String next = i+1<fields.length? fields[i+1] : null;
                if(next!=null) {
                    field += sep + next; fieldTrim = field.trim();
                    fields = ArrayUtils.remove(fields, i+1);
                }
                
                // If no next field, complain (shouldn't happen)
                else { System.err.println("CSVReader:getFields: missing close quote");
                    field += '\"'; fieldTrim = field.trim(); }
            }
            
            // Strip quotes
            fields[i] = fieldTrim.substring(1,fieldTrim.length()-1);
        }
    }
    
    // Return fields
    return fields;
}

}